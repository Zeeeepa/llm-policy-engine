# Example: JWT and Signing Key Secrets
#
# There are two approaches:
# 1. Symmetric (HS256): Single secret key
# 2. Asymmetric (RS256): Public/private key pair
#
# Usage:
#   # For HS256:
#   openssl rand -base64 32 > jwt-secret.txt
#   kubectl create secret generic jwt-secrets --from-file=jwt-secret=jwt-secret.txt --namespace=production --dry-run=client -o yaml | kubeseal -f - | kubectl apply -f -
#
#   # For RS256:
#   openssl genrsa -out private.pem 4096
#   openssl rsa -in private.pem -pubout -out public.pem
#   kubectl create secret generic jwt-secrets --from-file=private-key=private.pem --from-file=public-key=public.pem --namespace=production --dry-run=client -o yaml | kubeseal -f - | kubectl apply -f -

---
# APPROACH 1: Symmetric HMAC (HS256)
# Simpler but requires all services to have the secret
apiVersion: v1
kind: Secret
metadata:
  name: jwt-hmac-secret
  namespace: production
  labels:
    component: authentication
    algorithm: HS256
type: Opaque
stringData:
  # Base64-encoded 32-byte random key for HS256
  jwt-secret: "dGhpc2lzYXZlcnlzZWN1cmVqd3RzZWNyZXRrZXkzMmJ5dGVz"
  # Or use: openssl rand -base64 32

---
# APPROACH 2: Asymmetric RSA (RS256)
# Better for microservices - public key can be shared
apiVersion: v1
kind: Secret
metadata:
  name: jwt-signing-secrets
  namespace: production
  labels:
    component: authentication
    algorithm: RS256
type: Opaque
stringData:
  # Private key for signing (keep secret)
  private-key: |
    -----BEGIN PRIVATE KEY-----
    MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQC7VJTUt9Us8cKj
    MzEfYyjiWA4/4ORl2p5vmYSKe8LOt7WbTREqg6K2xoGKYQvVRVmX6BVZPVJZUJY2
    ...
    -----END PRIVATE KEY-----

  # Public key for verification (can be shared)
  public-key: |
    -----BEGIN PUBLIC KEY-----
    MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAu1SU1LfVLXflCsiqencrD
    ...
    -----END PUBLIC KEY-----

  # Additional metadata
  issuer: "https://auth.example.com"
  audience: "api.example.com"

---
# For key rotation: Keep old public key for verification during transition
apiVersion: v1
kind: Secret
metadata:
  name: jwt-signing-secrets-rotated
  namespace: production
  labels:
    component: authentication
    algorithm: RS256
    rotation: "true"
type: Opaque
stringData:
  # New keys (current)
  private-key-v2: |
    -----BEGIN PRIVATE KEY-----
    MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQC7VJTUt9Us8cKj
    ...
    -----END PRIVATE KEY-----

  public-key-v2: |
    -----BEGIN PUBLIC KEY-----
    MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAu1SU1LfVLXflCsiqencrD
    ...
    -----END PUBLIC KEY-----

  # Old keys (for verification only during transition)
  public-key-v1: |
    -----BEGIN PUBLIC KEY-----
    MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAu1SU1LfVLXflCsiqencrD
    ...
    -----END PUBLIC KEY-----

  public-key-v1-rotated-date: "2024-11-01T00:00:00Z"

---
# After sealing, the secret becomes (example format):
#
# apiVersion: bitnami.com/v1alpha1
# kind: SealedSecret
# metadata:
#   name: jwt-signing-secrets
#   namespace: production
#   labels:
#     component: authentication
#     algorithm: RS256
# spec:
#   encryptionKey: sealed-secrets-key
#   template:
#     metadata:
#       name: jwt-signing-secrets
#       namespace: production
#       labels:
#         component: authentication
#         algorithm: RS256
#     type: Opaque
#   encryptedData:
#     private-key: AgBvK8xA9K2zN4pQ2R3sT4uV5wX6yZ7aA8bC9dE0f...
#     public-key: AgCdL2mB7F3sO5rT6uV7wX8yZ9aB0cD1eF2gG3h...
#     issuer: AgEvM9nC3G4uP6sU7vW8xY9zA1bC2dE3fG4hH5i...
#     audience: AgFwN0oD1pE2qF3rG4sH5tI6uJ7vK8wL9xM0y...

---
# Usage in Auth Service (Signing)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: auth-service
  namespace: production
spec:
  replicas: 2
  selector:
    matchLabels:
      app: auth-service
  template:
    metadata:
      labels:
        app: auth-service
    spec:
      containers:
      - name: auth
        image: myapp/auth:1.0.0
        env:
        - name: JWT_PRIVATE_KEY_PATH
          value: /etc/jwt/private-key.pem
        - name: JWT_ISSUER
          valueFrom:
            secretKeyRef:
              name: jwt-signing-secrets
              key: issuer
        - name: JWT_AUDIENCE
          valueFrom:
            secretKeyRef:
              name: jwt-signing-secrets
              key: audience
        volumeMounts:
        - name: jwt-keys
          mountPath: /etc/jwt
          readOnly: true
        ports:
        - containerPort: 3000
      volumes:
      - name: jwt-keys
        secret:
          secretName: jwt-signing-secrets
          defaultMode: 0400  # Read-only
          items:
          - key: private-key
            path: private-key.pem
          - key: public-key
            path: public-key.pem

---
# Usage in API Service (Verification)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api-service
  namespace: production
spec:
  replicas: 3
  selector:
    matchLabels:
      app: api-service
  template:
    metadata:
      labels:
        app: api-service
    spec:
      containers:
      - name: api
        image: myapp/api:1.0.0
        env:
        - name: JWT_PUBLIC_KEY_PATH
          value: /etc/jwt/public-key.pem
        - name: JWT_ISSUER
          valueFrom:
            secretKeyRef:
              name: jwt-signing-secrets
              key: issuer
        - name: JWT_AUDIENCE
          valueFrom:
            secretKeyRef:
              name: jwt-signing-secrets
              key: audience
        volumeMounts:
        - name: jwt-keys
          mountPath: /etc/jwt
          readOnly: true
        ports:
        - containerPort: 8080
      volumes:
      - name: jwt-keys
        secret:
          secretName: jwt-signing-secrets
          defaultMode: 0400
          items:
          - key: public-key
            path: public-key.pem

---
# Secret for OIDC/OAuth Scenarios
apiVersion: v1
kind: Secret
metadata:
  name: oauth-secrets
  namespace: production
  labels:
    component: authentication
    type: oauth
type: Opaque
stringData:
  # OAuth Provider Credentials
  client-id: "your-client-id-from-provider"
  client-secret: "your-client-secret-from-provider"

  # OIDC Configuration
  issuer-url: "https://accounts.google.com"  # or your OIDC provider
  authorization-endpoint: "https://accounts.google.com/o/oauth2/v2/auth"
  token-endpoint: "https://oauth2.googleapis.com/token"
  userinfo-endpoint: "https://openidconnect.googleapis.com/v1/userinfo"

  # Custom JWT signing for tokens issued by your service
  jwt-signing-secret: "your-jwt-signing-secret-for-custom-tokens"

---
# Usage: OIDC Provider Integration
apiVersion: apps/v1
kind: Deployment
metadata:
  name: oauth-service
  namespace: production
spec:
  replicas: 2
  selector:
    matchLabels:
      app: oauth-service
  template:
    metadata:
      labels:
        app: oauth-service
    spec:
      containers:
      - name: service
        image: myapp/oauth:1.0.0
        env:
        - name: OAUTH_CLIENT_ID
          valueFrom:
            secretKeyRef:
              name: oauth-secrets
              key: client-id
        - name: OAUTH_CLIENT_SECRET
          valueFrom:
            secretKeyRef:
              name: oauth-secrets
              key: client-secret
        - name: OIDC_ISSUER
          valueFrom:
            secretKeyRef:
              name: oauth-secrets
              key: issuer-url
        - name: JWT_SIGNING_SECRET
          valueFrom:
            secretKeyRef:
              name: oauth-secrets
              key: jwt-signing-secret
        ports:
        - containerPort: 3000
