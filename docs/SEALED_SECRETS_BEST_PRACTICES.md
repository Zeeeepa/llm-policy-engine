# Sealed Secrets Best Practices for Production Kubernetes

A comprehensive reference guide for implementing Bitnami Sealed Secrets in production Kubernetes environments.

## Table of Contents

1. [SealedSecret Manifest Structure](#sealedsecret-manifest-structure)
2. [Multi-Service Secret Organization](#multi-service-secret-organization)
3. [Database Credential Management](#database-credential-management)
4. [Redis Secret Management](#redis-secret-management)
5. [JWT and Signing Key Management](#jwt-and-signing-key-management)
6. [Secret Rotation Strategies](#secret-rotation-strategies)
7. [Backup and Recovery](#backup-and-recovery)
8. [Common Pitfalls](#common-pitfalls)
9. [Kubeseal Commands Reference](#kubeseal-commands-reference)
10. [Integration Patterns](#integration-patterns)

---

## SealedSecret Manifest Structure

### Standard SealedSecret Template

```yaml
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: my-sealed-secret
  namespace: default
  labels:
    app: my-app
    version: v1
  annotations:
    description: "Sealed secret for app configuration"
spec:
  encryptionKey: "sealed-secrets-key"  # Reference to sealing key (optional)
  template:
    metadata:
      name: my-secret
      namespace: default
      labels:
        app: my-app
      annotations:
        managed-by: sealed-secrets
    type: Opaque  # Opaque, kubernetes.io/dockercfg, etc.
  encryptedData:
    # Encrypted values go here (generated by kubeseal)
    my-key: AgBvK8xA9K...
    api-token: AgCdL2mB7F...
    password: AgEvM9nC3G...
```

### Template vs. Sealed Data

The `spec.template` section controls how the unsealed Secret will appear:

```yaml
spec:
  template:
    # These control the resulting Secret resource
    metadata:
      name: my-secret
      labels:
        app: my-app
      annotations:
        key: value
    type: Opaque  # Secret type
    data: {}      # Will be populated with encryptedData
  encryptedData:
    # Individual encrypted key-value pairs
    username: <encrypted-value>
    password: <encrypted-value>
```

### Encryption Scopes

Three encryption scope options control which clusters/namespaces can decrypt:

```yaml
# 1. STRICT SCOPE (Default) - Tied to specific name and namespace
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: strict-secret
  namespace: production
spec:
  encryptionKey: "sealed-secrets-key"
  # Encrypted with specific name and namespace as part of the key
  encryptedData:
    key: AgBvK8xA9K...
  template:
    metadata:
      name: strict-secret
      namespace: production
    type: Opaque

---
# 2. NAMESPACE-WIDE SCOPE - Can be renamed within namespace
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: ns-secret
  namespace: production
  annotations:
    sealedsecrets.bitnami.com/namespace-wide: "true"
spec:
  encryptedData:
    key: AgBvK8xA9K...
  template:
    metadata:
      name: ns-secret
      namespace: production
    type: Opaque

---
# 3. CLUSTER-WIDE SCOPE - No name/namespace restrictions
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: cluster-secret
  namespace: any-namespace
  annotations:
    sealedsecrets.bitnami.com/cluster-wide: "true"
spec:
  encryptedData:
    key: AgBvK8xA9K...
  template:
    metadata:
      name: cluster-secret
      namespace: any-namespace
    type: Opaque
```

**Scope Recommendation:**
- Use **strict** (default) for multi-tenant clusters
- Use **namespace-wide** for flexibility within trusted namespaces
- Use **cluster-wide** only for cluster-level configuration (rare)

---

## Multi-Service Secret Organization

### Directory Structure Best Practice

```
k8s/
├── sealed-secrets/
│   ├── 00-controller.yaml          # Controller deployment
│   └── keys/
│       ├── public-key.pem           # Public certificate (safe to commit)
│       └── private-key-backup.yaml  # Private key backup (DO NOT commit)
│
├── namespaces/
│   ├── development/
│   │   ├── namespace.yaml
│   │   └── secrets/
│   │       ├── app-secrets.yaml
│   │       ├── db-secrets.yaml
│   │       └── redis-secrets.yaml
│   ├── staging/
│   │   ├── namespace.yaml
│   │   └── secrets/
│   │       ├── app-secrets.yaml
│   │       ├── db-secrets.yaml
│   │       └── redis-secrets.yaml
│   └── production/
│       ├── namespace.yaml
│       └── secrets/
│           ├── app-secrets.yaml
│           ├── db-secrets.yaml
│           ├── redis-secrets.yaml
│           └── jwt-secrets.yaml
│
├── services/
│   ├── api/
│   │   ├── deployment.yaml
│   │   ├── service.yaml
│   │   └── configmap.yaml
│   ├── worker/
│   │   ├── deployment.yaml
│   │   └── configmap.yaml
│   └── scheduler/
│       ├── statefulset.yaml
│       └── configmap.yaml
```

### Namespace-Specific Organization

**Namespace Initialization:**

```yaml
# k8s/namespaces/production/namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: production
  labels:
    app.kubernetes.io/name: production
    app.kubernetes.io/part-of: llm-platform
    sealed-secrets-enabled: "true"
```

### Secret Naming Convention

```
Pattern: {service}-{secret-type}[-{version}]

Examples:
- api-database-secrets
- worker-jwt-secrets
- redis-connection-secrets
- scheduler-aws-credentials
- logging-api-key
```

### Multi-Service Secret Example

```yaml
# k8s/namespaces/production/secrets/shared-secrets.yaml
---
# Database credentials shared across services
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: postgres-credentials
  namespace: production
  labels:
    component: data-layer
spec:
  encryptionKey: "sealed-secrets-key"
  template:
    metadata:
      name: postgres-credentials
      namespace: production
      labels:
        component: data-layer
    type: Opaque
  encryptedData:
    url: AgBvK8xA9K2zN4pQ...
    username: AgCdL2mB7F3sO5rT...
    password: AgEvM9nC3G4uP6sU...

---
# Redis connection
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: redis-connection
  namespace: production
  labels:
    component: cache-layer
spec:
  encryptionKey: "sealed-secrets-key"
  template:
    metadata:
      name: redis-connection
      namespace: production
      labels:
        component: cache-layer
    type: Opaque
  encryptedData:
    url: AgBvK8xA9K2zN4pQ...
    password: AgCdL2mB7F3sO5rT...

---
# Application-specific secrets
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: api-secrets
  namespace: production
  labels:
    app: api-service
spec:
  encryptionKey: "sealed-secrets-key"
  template:
    metadata:
      name: api-secrets
      namespace: production
      labels:
        app: api-service
    type: Opaque
  encryptedData:
    jwt-secret: AgBvK8xA9K2zN4pQ...
    api-key: AgCdL2mB7F3sO5rT...
    signing-key: AgEvM9nC3G4uP6sU...
```

---

## Database Credential Management

### PostgreSQL Secrets

```yaml
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: postgresql-credentials
  namespace: production
  labels:
    component: database
    database: postgresql
spec:
  encryptionKey: "sealed-secrets-key"
  template:
    metadata:
      name: postgresql-credentials
      namespace: production
      labels:
        component: database
    type: Opaque
  encryptedData:
    # Format: postgresql://user:password@host:port/database
    url: AgBvK8xA9K2zN4pQ2R3sT4uV5wX6yZ7aA8bC9d...
    host: AgCdL2mB7F3sO5rT6uV7wX8yZ9aB0cD1eF2g...
    port: AgEvM9nC3G4uP6sU7vW8xY9zA1bC2dE3fG4h...
    user: AgFwN0oD1pE2qF3rG4sH5tI6uJ7vK8wL9xM0...
    password: AgGxO1pE2qF3rG4sH5tI6uJ7vK8wL9xM0yN1...
    database: AgHyP2qF3rG4sH5tI6uJ7vK8wL9xM0yN1zO2...
    sslmode: AgIzQ3rG4sH5tI6uJ7vK8wL9xM0yN1zO2aP3...
```

**Usage in Deployment:**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api-service
  namespace: production
spec:
  template:
    spec:
      containers:
      - name: api
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: postgresql-credentials
              key: url
        - name: DB_HOST
          valueFrom:
            secretKeyRef:
              name: postgresql-credentials
              key: host
        - name: DB_USER
          valueFrom:
            secretKeyRef:
              name: postgresql-credentials
              key: user
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: postgresql-credentials
              key: password
```

### MySQL Secrets

```yaml
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: mysql-credentials
  namespace: production
  labels:
    component: database
    database: mysql
spec:
  encryptionKey: "sealed-secrets-key"
  template:
    metadata:
      name: mysql-credentials
      namespace: production
    type: Opaque
  encryptedData:
    # Format: mysql://user:password@host:port/database
    url: AgBvK8xA9K2zN4pQ...
    host: AgCdL2mB7F3sO5rT...
    port: AgEvM9nC3G4uP6sU...
    user: AgFwN0oD1pE2qF3rG...
    password: AgGxO1pE2qF3rG4s...
    database: AgHyP2qF3rG4sH5t...
    root_password: AgIzQ3rG4sH5tI6u...
```

### MongoDB Secrets

```yaml
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: mongodb-credentials
  namespace: production
  labels:
    component: database
    database: mongodb
spec:
  encryptionKey: "sealed-secrets-key"
  template:
    metadata:
      name: mongodb-credentials
      namespace: production
    type: Opaque
  encryptedData:
    # Format: mongodb://user:password@host:port/database
    url: AgBvK8xA9K2zN4pQ...
    connection_string: AgCdL2mB7F3sO5rT...
    username: AgEvM9nC3G4uP6sU...
    password: AgFwN0oD1pE2qF3rG...
    database: AgGxO1pE2qF3rG4s...
    replica_set: AgHyP2qF3rG4sH5t...
```

### Best Practices for Database Secrets

1. **Store connection strings as single URLs** when possible for easier rotation
2. **Provide individual fields** (host, port, user, password) for services that need them
3. **Use TLS/SSL by default** - include certificates in ConfigMaps, credentials in Secrets
4. **Rotate quarterly** - coordinate with DBA team for zero-downtime rotation
5. **Use service accounts** - give each application only the credentials it needs

---

## Redis Secret Management

### Redis with Password

```yaml
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: redis-credentials
  namespace: production
  labels:
    component: cache
    service: redis
spec:
  encryptionKey: "sealed-secrets-key"
  template:
    metadata:
      name: redis-credentials
      namespace: production
      labels:
        component: cache
    type: Opaque
  encryptedData:
    # Format: redis://:password@host:port/db
    url: AgBvK8xA9K2zN4pQ...
    host: AgCdL2mB7F3sO5rT...
    port: AgEvM9nC3G4uP6sU...
    password: AgFwN0oD1pE2qF3rG...
    db: AgGxO1pE2qF3rG4s...
```

### Redis Cluster Credentials

```yaml
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: redis-cluster-credentials
  namespace: production
  labels:
    component: cache
    service: redis-cluster
spec:
  encryptionKey: "sealed-secrets-key"
  template:
    metadata:
      name: redis-cluster-credentials
      namespace: production
    type: Opaque
  encryptedData:
    # Multiple nodes for cluster
    url: AgBvK8xA9K2zN4pQ...  # redis-sentinel://...
    nodes: AgCdL2mB7F3sO5rT...
    password: AgEvM9nC3G4uP6sU...
    sentinel_password: AgFwN0oD1pE2qF3rG...
```

### Redis Sentinel Configuration

```yaml
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: redis-sentinel-credentials
  namespace: production
  labels:
    component: cache
    service: redis-sentinel
spec:
  encryptionKey: "sealed-secrets-key"
  template:
    metadata:
      name: redis-sentinel-credentials
      namespace: production
    type: Opaque
  encryptedData:
    master_name: AgBvK8xA9K2zN4pQ...
    sentinel_hosts: AgCdL2mB7F3sO5rT...
    sentinel_port: AgEvM9nC3G4uP6sU...
    master_password: AgFwN0oD1pE2qF3rG...
    sentinel_password: AgGxO1pE2qF3rG4s...
```

**Usage in Deployment:**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: cache-consumer
  namespace: production
spec:
  template:
    spec:
      containers:
      - name: app
        env:
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: redis-credentials
              key: url
        - name: REDIS_HOST
          valueFrom:
            secretKeyRef:
              name: redis-credentials
              key: host
        - name: REDIS_PORT
          valueFrom:
            secretKeyRef:
              name: redis-credentials
              key: port
        - name: REDIS_PASSWORD
          valueFrom:
            secretKeyRef:
              name: redis-credentials
              key: password
```

### Best Practices for Redis Secrets

1. **Store both URL and individual components** for flexibility
2. **Use Redis ACLs** - Kubernetes 6.0+ allows per-user authentication
3. **Rotate credentials quarterly** - especially for high-privilege accounts
4. **Test cache failover** with new credentials before rotation
5. **Monitor Redis slow log** - watch for authentication failures during rotation

---

## JWT and Signing Key Management

### JWT Secrets

```yaml
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: jwt-signing-secrets
  namespace: production
  labels:
    component: authentication
    secret-type: jwt
spec:
  encryptionKey: "sealed-secrets-key"
  template:
    metadata:
      name: jwt-signing-secrets
      namespace: production
      labels:
        component: authentication
    type: Opaque
  encryptedData:
    # HS256 (HMAC with SHA256) - symmetric key
    jwt-secret: AgBvK8xA9K2zN4pQ2R3sT4uV5wX6yZ7aA8bC9d...

    # RS256 (RSA with SHA256) - asymmetric keys
    private-key: AgCdL2mB7F3sO5rT6uV7wX8yZ9aB0cD1eF2g...
    public-key: AgEvM9nC3G4uP6sU7vW8xY9zA1bC2dE3fG4h...

    # Additional RS256 public key for client verification
    public-key-v2: AgFwN0oD1pE2qF3rG4sH5tI6uJ7vK8wL9xM0...

    # Token issuer and audience
    issuer: AgGxO1pE2qF3rG4sH5tI6uJ7vK8wL9xM0yN1...
    audience: AgHyP2qF3rG4sH5tI6uJ7vK8wL9xM0yN1zO2...
```

### OIDC/OAuth Secrets

```yaml
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: oauth-secrets
  namespace: production
  labels:
    component: authentication
    secret-type: oauth
spec:
  encryptionKey: "sealed-secrets-key"
  template:
    metadata:
      name: oauth-secrets
      namespace: production
    type: Opaque
  encryptedData:
    # OAuth provider configuration
    client-id: AgBvK8xA9K2zN4pQ...
    client-secret: AgCdL2mB7F3sO5rT...

    # OIDC specific
    issuer-url: AgEvM9nC3G4uP6sU...
    authorization-endpoint: AgFwN0oD1pE2qF3rG...
    token-endpoint: AgGxO1pE2qF3rG4s...
    userinfo-endpoint: AgHyP2qF3rG4sH5t...

    # JWT signing for custom tokens
    signing-secret: AgIzQ3rG4sH5tI6u...
```

### Asymmetric Key Pair Generation and Sealing

```bash
# Generate RSA key pair (2048-bit minimum, 4096-bit recommended)
openssl genrsa -out private.pem 4096
openssl rsa -in private.pem -pubout -out public.pem

# Create Kubernetes Secret from keys
kubectl create secret generic jwt-keys \
  --from-file=private-key=private.pem \
  --from-file=public-key=public.pem \
  --namespace=production \
  --dry-run=client \
  -o yaml > jwt-secret.yaml

# Seal the secret
kubeseal \
  --format yaml \
  --namespace production \
  < jwt-secret.yaml > sealed-jwt-secret.yaml
```

### HMAC Key Generation and Sealing

```bash
# Generate a strong random key (32 bytes for HS256)
openssl rand -base64 32 > jwt-secret.txt

# Create Kubernetes Secret
kubectl create secret generic jwt-hmac-secret \
  --from-file=jwt-secret=jwt-secret.txt \
  --namespace=production \
  --dry-run=client \
  -o yaml > jwt-hmac-secret.yaml

# Seal the secret
kubeseal \
  --format yaml \
  --namespace production \
  < jwt-hmac-secret.yaml > sealed-jwt-hmac-secret.yaml

# Clean up
rm jwt-secret.txt private.pem
```

**Usage in Deployment:**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: auth-service
  namespace: production
spec:
  template:
    spec:
      containers:
      - name: app
        env:
        - name: JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: jwt-signing-secrets
              key: jwt-secret
        - name: JWT_ISSUER
          valueFrom:
            secretKeyRef:
              name: jwt-signing-secrets
              key: issuer
        - name: JWT_AUDIENCE
          valueFrom:
            secretKeyRef:
              name: jwt-signing-secrets
              key: audience
        volumeMounts:
        - name: jwt-keys
          mountPath: /etc/jwt
          readOnly: true
      volumes:
      - name: jwt-keys
        secret:
          secretName: jwt-signing-secrets
          defaultMode: 0400
```

### Best Practices for JWT/Signing Keys

1. **Use asymmetric keys (RS256)** for microservices - allows key rotation without updating all consumers
2. **Rotate signing keys quarterly** - keep old public key for verification transition period
3. **Support multiple public keys** - allows gradual transition during rotation
4. **Use volume mounts for key files** - more secure than environment variables
5. **Never log private keys** - configure logging to exclude secret fields
6. **Version your keys** - track which version signed each token

---

## Secret Rotation Strategies

### Key Rotation Workflow

```yaml
# Phase 1: Generate new key pair locally
# openssl genrsa -out new-private.pem 4096
# openssl rsa -in new-private.pem -pubout -out new-public.pem

# Phase 2: Create new SealedSecret with both old and new keys
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: jwt-signing-secrets
  namespace: production
  labels:
    component: authentication
spec:
  encryptionKey: "sealed-secrets-key"
  template:
    metadata:
      name: jwt-signing-secrets
      namespace: production
    type: Opaque
  encryptedData:
    # New primary key
    private-key: AgBvK8xA9K2zN4pQ...
    public-key: AgCdL2mB7F3sO5rT...

    # Old key for verification during transition
    public-key-v1: AgEvM9nC3G4uP6sU...
    public-key-v1-rotated-date: AgFwN0oD1pE2qF3rG...
```

### Database Credential Rotation

```bash
# Step 1: Generate new credentials in database
# ALTER ROLE api_user WITH PASSWORD 'new_secure_password';

# Step 2: Create new Sealed Secret locally
kubectl create secret generic postgresql-credentials \
  --from-literal=user=api_user \
  --from-literal=password=new_secure_password \
  --from-literal=url="postgresql://api_user:new_secure_password@db.prod.svc:5432/appdb" \
  --namespace=production \
  --dry-run=client \
  -o yaml > new-db-secret.yaml

# Step 3: Seal it
kubeseal \
  --format yaml \
  --namespace production \
  < new-db-secret.yaml > new-db-secret-sealed.yaml

# Step 4: Apply to cluster and verify new connections work
kubectl apply -f new-db-secret-sealed.yaml

# Step 5: Verify pods reconnected with new credentials
kubectl rollout restart deployment api-service -n production

# Step 6: Revoke old credentials after successful rotation
# DROP ROLE old_api_user;
```

### Automatic Key Renewal Configuration

The Sealed Secrets controller automatically renews certificates every 30 days:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: sealed-secrets-controller
  namespace: kube-system
spec:
  template:
    spec:
      containers:
      - name: sealed-secrets-controller
        args:
        - --update-status
        - --key-prefix=sealed-secrets-key
        - --key-rotation-period=720h  # 30 days in hours
        - --key-rotation-failure-delay=1h
```

**Important**: Automatic certificate renewal is NOT the same as secret rotation. You must:
1. Rotate the actual secrets (passwords, tokens, keys) separately
2. Only the encryption certificate rotates automatically
3. Old sealed secrets remain valid with the old encryption key

### Zero-Downtime Secret Rotation Pattern

```bash
#!/bin/bash
set -e

NAMESPACE="production"
SECRET_NAME="api-secrets"

# Phase 1: Generate and seal new secret
echo "Generating new secret..."
NEW_API_KEY=$(openssl rand -base64 32)

# Create temporary secret file
kubectl create secret generic $SECRET_NAME-temp \
  --from-literal=api-key="$NEW_API_KEY" \
  --namespace=$NAMESPACE \
  --dry-run=client \
  -o yaml > /tmp/new-secret.yaml

# Seal it
kubeseal -f /tmp/new-secret.yaml -w /tmp/sealed-secret.yaml

# Phase 2: Update deployment to accept both old and new keys
echo "Updating deployment configuration..."
kubectl set env deployment/api-service \
  -n $NAMESPACE \
  ACCEPT_NEW_API_KEY=true

# Phase 3: Apply new sealed secret to cluster
echo "Applying new sealed secret..."
kubectl apply -f /tmp/sealed-secret.yaml

# Phase 4: Rolling restart to pick up new secret
echo "Rolling restart..."
kubectl rollout restart deployment/api-service -n $NAMESPACE
kubectl rollout status deployment/api-service -n $NAMESPACE

# Phase 5: Monitor and verify
echo "Verifying new key acceptance..."
sleep 10
kubectl logs deployment/api-service -n $NAMESPACE --tail=20 | grep "api-key"

# Phase 6: Remove old key acceptance after verification
echo "Cleanup: Disabling old key acceptance..."
kubectl set env deployment/api-service \
  -n $NAMESPACE \
  ACCEPT_OLD_API_KEY=false

# Final restart
kubectl rollout restart deployment/api-service -n $NAMESPACE

echo "Secret rotation completed successfully"
```

### Rotation Schedule Recommendations

| Secret Type | Rotation Frequency | Reason |
|---|---|---|
| Database Passwords | Quarterly (90 days) | Critical - coordinate with DBAs |
| API Keys | Monthly (30 days) | External service keys |
| JWT Signing Keys | Bi-annually (180 days) | Low frequency - allows client transition time |
| Redis Passwords | Quarterly (90 days) | Tied to database rotation |
| OAuth Secrets | Quarterly (90 days) | Same as API keys |
| Encryption Keys | Annually | Sealed Secrets - rotation via re-sealing |

---

## Backup and Recovery

### Backup Strategy

#### 1. Export Private Sealing Key

```bash
# Backup the private sealing key (DO NOT COMMIT TO GIT)
kubectl get secret -n kube-system sealed-secrets-key \
  -o yaml > /secure/location/sealed-secrets-key-backup.yaml

# Verify backup contains the private key
# Store with encryption:
openssl enc -aes-256-cbc -in sealed-secrets-key-backup.yaml \
  -out sealed-secrets-key-backup.yaml.enc -pass pass:STRONG_PASSWORD

# Secure backup location options:
# - Encrypted external drive
# - Password-protected cloud storage (AWS S3 with encryption)
# - Hardware security module (HSM)
# - Air-gapped backup server
```

#### 2. Export Public Certificate

```bash
# Public certificate is safe to commit to Git
kubeseal --fetch-cert > k8s/sealed-secrets/keys/public-key.pem

# Also store in ConfigMap for reference
kubectl get secret -n kube-system -l sealedsecrets.bitnami.com/sealed-secrets-key \
  -o jsonpath='{.items[0].data.tls\.crt}' | base64 -d > public-key.pem
```

#### 3. Backup All SealedSecrets

```bash
# Export all SealedSecrets from cluster
kubectl get sealedsecrets -A -o yaml > all-sealedsecrets-backup.yaml

# Store in version control:
git add k8s/sealed-secrets/keys/public-key.pem
git add all-sealedsecrets-backup.yaml
git commit -m "Backup: SealedSecrets manifests"

# Keep private key separate from version control
```

#### 4. Automated Backup Script

```bash
#!/bin/bash
set -e

BACKUP_DIR="/mnt/backup/sealed-secrets/$(date +%Y%m%d)"
ENCRYPTION_PASSWORD="${BACKUP_PASSWORD}"

mkdir -p "$BACKUP_DIR"

echo "Backing up Sealed Secrets configuration..."

# Backup all SealedSecrets
kubectl get sealedsecrets -A -o yaml \
  > "$BACKUP_DIR/sealedsecrets-all.yaml"

# Backup private key
kubectl get secret -n kube-system sealed-secrets-key -o yaml \
  > "$BACKUP_DIR/sealing-key.yaml"

# Backup public certificate
kubeseal --fetch-cert > "$BACKUP_DIR/public-key.pem"

# Encrypt sensitive files
openssl enc -aes-256-cbc \
  -in "$BACKUP_DIR/sealing-key.yaml" \
  -out "$BACKUP_DIR/sealing-key.yaml.enc" \
  -pass pass:$ENCRYPTION_PASSWORD

# Remove unencrypted private key
rm "$BACKUP_DIR/sealing-key.yaml"

# Create backup manifest
cat > "$BACKUP_DIR/backup-manifest.txt" <<EOF
Sealed Secrets Backup
Generated: $(date)
Contents:
- sealedsecrets-all.yaml: All SealedSecret resources
- sealing-key.yaml.enc: Private sealing key (encrypted)
- public-key.pem: Public certificate (safe)
EOF

echo "Backup completed at: $BACKUP_DIR"
```

### Recovery Procedures

#### Scenario 1: Node/Pod Lost

No action needed - SealedSecrets remain in cluster via etcd backup.

#### Scenario 2: Controller Pod Crashed

```bash
# Controller will restart and pull key from etcd
# Monitor restart:
kubectl get pods -n kube-system -l name=sealed-secrets-controller

# If key is corrupted:
# 1. Delete the corrupted secret
kubectl delete secret sealed-secrets-key -n kube-system

# 2. Restore from backup
openssl enc -d -aes-256-cbc \
  -in sealed-secrets-key-backup.yaml.enc \
  -pass pass:STRONG_PASSWORD | kubectl apply -f -

# 3. Restart controller
kubectl rollout restart deployment/sealed-secrets-controller -n kube-system
```

#### Scenario 3: Cluster Destroyed

```bash
# Restore from backup (manual process):

# 1. Install new cluster and Sealed Secrets controller
kubectl apply -f k8s/sealed-secrets/00-controller.yaml

# 2. Restore the private key
openssl enc -d -aes-256-cbc \
  -in sealed-secrets-key-backup.yaml.enc \
  -pass pass:STRONG_PASSWORD | kubectl apply -f -

# 3. Verify key is in place
kubectl get secret -n kube-system sealed-secrets-key

# 4. Restart controller to use restored key
kubectl rollout restart deployment/sealed-secrets-controller -n kube-system

# 5. Verify controller is ready
kubectl wait --for=condition=ready pod \
  -l name=sealed-secrets-controller \
  -n kube-system \
  --timeout=300s

# 6. Apply SealedSecrets from backup
kubectl apply -f all-sealedsecrets-backup.yaml

# 7. Verify secrets unsealed correctly
kubectl get secrets -A
```

#### Scenario 4: Lost Private Key (No Backup)

**Consequence**: All existing SealedSecrets become unrecoverable.

**Recovery steps**:
1. Generate new sealing key (automatic on first controller start)
2. Collect all plain-text secrets manually
3. Re-seal everything with new key
4. Deploy new SealedSecrets
5. Rotate all actual credentials

**Prevention**: Implement automated encrypted backups.

### Backup Verification

```bash
#!/bin/bash

echo "Verifying Sealed Secrets backup..."

# Check private key is encrypted
if ! file sealed-secrets-key-backup.yaml.enc | grep -q "openssl encrypted data"; then
  echo "ERROR: Key file is not encrypted"
  exit 1
fi

# Verify public certificate
if ! openssl x509 -in public-key.pem -noout >/dev/null 2>&1; then
  echo "ERROR: Public certificate is invalid"
  exit 1
fi

# Verify manifests are valid YAML
if ! kubectl apply -f all-sealedsecrets-backup.yaml --dry-run=client >/dev/null 2>&1; then
  echo "ERROR: Manifests are invalid"
  exit 1
fi

echo "Backup verification successful"
```

### Off-Site Backup Storage

```bash
# AWS S3 encrypted backup
aws s3 cp sealed-secrets-key-backup.yaml.enc \
  s3://backup-bucket/k8s/sealed-secrets/$(date +%Y%m%d)/ \
  --sse-c-algorithm AES256 \
  --sse-c-key $(cat /secure/kms-key.txt)

# GCS encrypted backup
gsutil -h "Cache-Control:no-cache" \
  -h "Content-Encoding:gzip" \
  cp sealed-secrets-key-backup.yaml.enc \
  gs://backup-bucket/k8s/sealed-secrets/$(date +%Y%m%d)/
```

---

## Common Pitfalls

### Pitfall 1: Committing Private Keys

**Problem**: Private key ends up in Git, compromising encryption.

```yaml
# WRONG - Don't do this
git add k8s/sealed-secrets/private-key-backup.yaml
git commit -m "Backup"
```

**Solution**:
```bash
# Add to .gitignore
echo "k8s/sealed-secrets/**/*-backup.yaml" >> .gitignore
echo "k8s/sealed-secrets/**/private-key*" >> .gitignore

# If already committed, remove from history
git rm --cached k8s/sealed-secrets/private-key-backup.yaml
git commit -m "Remove private key from history"
git push --force-with-lease

# Regenerate cluster key
kubectl delete secret sealed-secrets-key -n kube-system
# Controller will generate new key on restart
kubectl rollout restart deployment/sealed-secrets-controller -n kube-system
```

### Pitfall 2: Wrong Scope for SealedSecret

**Problem**: Using cluster-wide scope when strict scope is safer.

```yaml
# WRONG - Overly permissive
metadata:
  annotations:
    sealedsecrets.bitnami.com/cluster-wide: "true"

# RIGHT - Default strict scope
# (no annotation needed)
```

**Impact**: Secret can be moved to any namespace or renamed, reducing security.

### Pitfall 3: Forgetting Secret Rotation

**Problem**: Using same credentials for years creates breach risk.

**Solution**: Implement rotation schedule with alerts

```bash
# Create reminder in calendar
# Schedule quarterly reviews
# Automate with CronJobs
```

### Pitfall 4: No Backup of Private Key

**Problem**: Cluster loss results in unrecoverable secrets.

**Solution**: Implement automated encrypted backups to external storage.

### Pitfall 5: Sealing with Wrong Public Key

**Problem**: Sealing secret with development cluster key but deploying to production.

```bash
# WRONG - Using default/wrong key
kubeseal -f secret.yaml

# RIGHT - Specify cluster
kubeseal --cert k8s/sealed-secrets/keys/production-public-key.pem -f secret.yaml
```

### Pitfall 6: Not Updating Certificate Cache

**Problem**: Using stale offline certificate, sealing fails unexpectedly.

```bash
# Update certificate cache monthly
kubeseal --fetch-cert > k8s/sealed-secrets/keys/public-key.pem
git add k8s/sealed-secrets/keys/public-key.pem
git commit -m "Update sealing certificate cache ($(date +%Y-%m))"
```

### Pitfall 7: Exposing Secrets in Logs

**Problem**: Secret values leak into application logs.

```yaml
# Configure logging to exclude secrets
# Update logging configuration:
logrus.SetLevel(logrus.InfoLevel)

# In code, mask secret values:
log.Printf("Connected to DB: %s@%s", user, "***hidden***")

# Use structured logging with field masking:
log.WithField("password", "***").Info("Database connected")
```

### Pitfall 8: Not Testing Secret Rotation

**Problem**: Rotation fails in production because it wasn't tested.

**Solution**: Test rotation in staging first

```bash
# 1. Plan rotation in staging cluster
# 2. Document all steps
# 3. Run through complete procedure
# 4. Verify no downtime
# 5. Get team approval
# 6. Execute in production
```

### Pitfall 9: Multiple Controllers in Different Namespaces

**Problem**: Controllers with different keys cause decryption failures.

```yaml
# WRONG - Multiple controllers
kube-system:
  sealed-secrets-controller (key A)
development:
  sealed-secrets-controller (key B)  # Different keys!
```

**Right Approach**:
- One controller per cluster (in kube-system)
- One sealing key per cluster
- Use namespaces for environment isolation, not separate controllers

### Pitfall 10: Not Documenting Secret Rotation Procedures

**Problem**: Team member doesn't know how to rotate when key person absent.

**Solution**: Document everything

```markdown
# Secret Rotation Procedures

## Database Credentials
1. Generate new password in database: ...
2. Create sealed secret: ...
3. Apply to cluster: ...
4. Verify: ...
5. Revoke old: ...

## JWT Keys
1. Generate new RSA key: ...
2. Create sealed secret with old and new keys: ...
...
```

---

## Kubeseal Commands Reference

### Installation

```bash
# Install kubeseal CLI
# macOS
brew install kubeseal

# Linux
wget https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.24.5/kubeseal-0.24.5-linux-amd64.tar.gz
tar xfz kubeseal-0.24.5-linux-amd64.tar.gz
sudo mv kubeseal /usr/local/bin/

# Verify installation
kubeseal --version
```

### Basic Sealing Operations

```bash
# Fetch cluster's public certificate
kubeseal --fetch-cert > my-cert.pem

# Seal a secret (interactive)
kubectl create secret generic my-secret \
  --from-literal=key=value \
  --namespace=production \
  --dry-run=client \
  -o yaml | kubeseal -f -

# Seal with offline certificate
kubeseal \
  --cert my-cert.pem \
  --format yaml \
  -f secret.yaml \
  -w sealed-secret.yaml

# Seal with specific scope
kubeseal \
  --scope namespace-wide \
  -f secret.yaml \
  -w sealed-secret.yaml

# Seal with cluster-wide scope
kubeseal \
  --scope cluster-wide \
  -f secret.yaml \
  -w sealed-secret.yaml

# Seal for different namespace
kubeseal \
  --namespace staging \
  -f secret.yaml \
  -w sealed-secret.yaml
```

### Advanced Sealing

```bash
# Seal individual values
echo -n "mysecretvalue" | kubeseal \
  --scope namespace-wide \
  --raw

# Seal and output to specific file
kubeseal \
  --format=json \
  < secret.yaml > sealed-secret.json

# Seal with custom encryption key
kubeseal \
  --key-prefix my-custom-key \
  -f secret.yaml \
  -w sealed-secret.yaml

# Seal multiple secrets from directory
for file in secrets/*.yaml; do
  kubeseal -f "$file" -w "sealed-${file%.yaml}.yaml"
done
```

### Certificate Management

```bash
# Fetch certificate and save locally
kubeseal --fetch-cert > sealed-secrets-cert.pem

# Validate certificate
openssl x509 -in sealed-secrets-cert.pem -text -noout

# Check certificate expiry
openssl x509 -in sealed-secrets-cert.pem -noout -enddate

# Use cached certificate for sealing
kubeseal \
  --cert sealed-secrets-cert.pem \
  -f secret.yaml \
  -w sealed-secret.yaml
```

### Inspection Commands

```bash
# List all sealed secrets in cluster
kubectl get sealedsecrets -A

# Get sealed secret details
kubectl get sealedsecrets -n production my-secret -o yaml

# Describe sealed secret (check status)
kubectl describe sealedsecrets -n production my-secret

# Get decrypted secret (if you have permissions)
kubectl get secrets -n production my-secret -o yaml

# Watch sealing status
kubectl get sealedsecrets -A -w
```

### Troubleshooting Commands

```bash
# Check controller logs
kubectl logs -n kube-system -l name=sealed-secrets-controller -f

# Check controller events
kubectl describe deployment sealed-secrets-controller -n kube-system

# Test sealing key accessibility
kubeseal --fetch-cert | openssl x509 -text -noout

# Verify sealed secret can be unsealed
kubectl get sealedsecrets -n production my-secret -o yaml | kubectl apply -f - --dry-run=client

# Check RBAC permissions
kubectl auth can-i get sealedsecrets -n production
kubectl auth can-i create secrets -n production
```

### Batch Operations

```bash
# Re-seal all secrets with new key
for secret in $(kubectl get sealedsecrets -A -o jsonpath='{.items[*].metadata.name}'); do
  kubectl get sealedsecrets $secret -o yaml | kubeseal --re-seal -f -
done

# Export all secrets for backup
kubectl get sealedsecrets -A -o yaml > backup-all-sealedsecrets.yaml

# Update all sealing keys to specific version
kubectl get sealedsecrets -A -o jsonpath='{.items[*]}' | \
  jq '.[] |= .spec.encryptionKey = "sealed-secrets-key-v2"' | \
  kubectl apply -f -
```

---

## Integration Patterns

### Pattern 1: Deployment with Sealed Secrets

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: app-namespace

---
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: app-secrets
  namespace: app-namespace
spec:
  template:
    metadata:
      name: app-secrets
    type: Opaque
  encryptedData:
    database-url: AgBvK8xA9K2zN4pQ...
    api-key: AgCdL2mB7F3sO5rT...

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app
  namespace: app-namespace
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
      - name: app
        image: my-app:1.0.0
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: app-secrets
              key: database-url
        - name: API_KEY
          valueFrom:
            secretKeyRef:
              name: app-secrets
              key: api-key
        ports:
        - containerPort: 3000
```

### Pattern 2: StatefulSet with Database Secrets

```yaml
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: db-credentials
  namespace: databases
spec:
  template:
    metadata:
      name: db-credentials
    type: Opaque
  encryptedData:
    root-password: AgBvK8xA9K2zN4pQ...
    replication-password: AgCdL2mB7F3sO5rT...

---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: postgres
  namespace: databases
spec:
  serviceName: postgres
  replicas: 3
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      containers:
      - name: postgres
        image: postgres:15
        env:
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: db-credentials
              key: root-password
        - name: PGPASSWORD
          valueFrom:
            secretKeyRef:
              name: db-credentials
              key: replication-password
        ports:
        - containerPort: 5432
        volumeMounts:
        - name: data
          mountPath: /var/lib/postgresql/data
  volumeClaimTemplates:
  - metadata:
      name: data
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 100Gi
```

### Pattern 3: CronJob with Secrets

```yaml
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: backup-credentials
  namespace: backups
spec:
  template:
    metadata:
      name: backup-credentials
    type: Opaque
  encryptedData:
    s3-access-key: AgBvK8xA9K2zN4pQ...
    s3-secret-key: AgCdL2mB7F3sO5rT...
    database-url: AgEvM9nC3G4uP6sU...

---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: database-backup
  namespace: backups
spec:
  schedule: "0 2 * * *"  # Daily at 2 AM
  jobTemplate:
    spec:
      template:
        spec:
          serviceAccountName: backup-sa
          containers:
          - name: backup
            image: postgres:15
            env:
            - name: AWS_ACCESS_KEY_ID
              valueFrom:
                secretKeyRef:
                  name: backup-credentials
                  key: s3-access-key
            - name: AWS_SECRET_ACCESS_KEY
              valueFrom:
                secretKeyRef:
                  name: backup-credentials
                  key: s3-secret-key
            - name: DATABASE_URL
              valueFrom:
                secretKeyRef:
                  name: backup-credentials
                  key: database-url
            command:
            - /bin/sh
            - -c
            - pg_dump "$DATABASE_URL" | gzip | aws s3 cp - "s3://backups/$(date +%Y%m%d).sql.gz"
          restartPolicy: OnFailure
```

### Pattern 4: Secret Mounting as Files

```yaml
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: tls-certificates
  namespace: secure-app
spec:
  template:
    metadata:
      name: tls-certificates
    type: kubernetes.io/tls
  encryptedData:
    tls.crt: AgBvK8xA9K2zN4pQ...
    tls.key: AgCdL2mB7F3sO5rT...

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: secure-app
  namespace: secure-app
spec:
  template:
    spec:
      containers:
      - name: app
        image: secure-app:1.0.0
        volumeMounts:
        - name: tls-certs
          mountPath: /etc/tls
          readOnly: true
        ports:
        - containerPort: 443
      volumes:
      - name: tls-certs
        secret:
          secretName: tls-certificates
          defaultMode: 0400
          items:
          - key: tls.crt
            path: cert.pem
          - key: tls.key
            path: key.pem
```

### Pattern 5: Multi-Environment Secret Management

```yaml
# Development
---
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: app-secrets
  namespace: development
spec:
  template:
    metadata:
      name: app-secrets
    type: Opaque
  encryptedData:
    api-url: AgBvK8xA9K2zN4pQ...  # dev endpoint
    log-level: AgCdL2mB7F3sO5rT...

---
# Staging
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: app-secrets
  namespace: staging
spec:
  template:
    metadata:
      name: app-secrets
    type: Opaque
  encryptedData:
    api-url: AgEvM9nC3G4uP6sU...  # staging endpoint
    log-level: AgFwN0oD1pE2qF3rG...

---
# Production
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: app-secrets
  namespace: production
spec:
  template:
    metadata:
      name: app-secrets
    type: Opaque
  encryptedData:
    api-url: AgGxO1pE2qF3rG4s...  # production endpoint
    log-level: AgHyP2qF3rG4sH5t...  # error level
```

---

## Security Considerations Summary

### Access Control

1. **RBAC for Sealed Secrets**
   ```yaml
   apiVersion: rbac.authorization.k8s.io/v1
   kind: ClusterRole
   metadata:
     name: sealedsecrets-reader
   rules:
   - apiGroups: ["bitnami.com"]
     resources: ["sealedsecrets"]
     verbs: ["get", "list", "watch"]

   # Restrict who can CREATE sealedsecrets
   - apiGroups: ["bitnami.com"]
     resources: ["sealedsecrets"]
     verbs: ["create"]
     # Only specific service accounts or users
   ```

2. **Secret Access Control**
   ```yaml
   # Only specific services should read the unsealed secret
   apiVersion: rbac.authorization.k8s.io/v1
   kind: Role
   metadata:
     name: app-secret-reader
     namespace: production
   rules:
   - apiGroups: [""]
     resources: ["secrets"]
     resourceNames: ["app-secrets"]  # Only specific secret
     verbs: ["get"]
   ```

### Encryption Standards

- **Key Size**: Minimum 2048-bit RSA, 4096-bit recommended
- **Cipher**: AES-256 (GCM mode)
- **Key Rotation**: Automatic certificate renewal every 30 days
- **Scope Binding**: Namespace and name included in encryption by default

### Network Security

- Controller communication over HTTPS
- Secret API endpoint access via RBAC
- Consider network policies to restrict secret access

### Audit and Monitoring

```yaml
# Enable API audit logging for secret operations
apiVersion: audit.k8s.io/v1
kind: Policy
rules:
- level: RequestResponse
  omitStages:
  - RequestReceived
  resources:
  - group: "bitnami.com"
    resources: ["sealedsecrets"]
  namespaces: ["kube-system", "production"]
```

---

## Frequently Asked Questions

### Q: Can I unseal a SealedSecret without the controller?
**A**: No. Only the controller with the private key can unseal. This is intentional for security.

### Q: What happens if I lose the private key?
**A**: All existing SealedSecrets become unrecoverable. Always backup the key.

### Q: Can I move a sealed secret to a different namespace?
**A**: Only with namespace-wide or cluster-wide scope. Strict scope prevents this.

### Q: How often should I rotate secrets?
**A**: Database/API keys: quarterly. JWT signing keys: annually. Always when compromise suspected.

### Q: Can I use Sealed Secrets with GitOps tools?
**A**: Yes. ArgoCD, Flux, and others work seamlessly. Sealed secrets are safe to commit.

### Q: Do I need to update sealed secrets when the controller certificate renews?
**A**: No. Old sealed secrets remain valid. Certificate renewal doesn't require action.

### Q: How do I handle secrets for multiple clusters?
**A**: Each cluster has its own sealing key. Seal secrets per cluster.

### Q: Can sealed secrets be decrypted outside the cluster?
**A**: No. Only the controller with the private key can decrypt them.

---

## Implementation Checklist

- [ ] Sealed Secrets controller installed in kube-system
- [ ] Public certificate backed up to version control
- [ ] Private key backed up to encrypted offline storage
- [ ] All secrets converted to SealedSecrets
- [ ] RBAC policies configured for secret access
- [ ] Secret rotation schedule documented
- [ ] Team trained on kubeseal commands
- [ ] Automated backup script implemented
- [ ] Disaster recovery procedure documented
- [ ] Network policies restrict secret access
- [ ] Audit logging configured
- [ ] Monitoring alerts for controller health
- [ ] Certificate renewal monitoring in place
- [ ] Secret rotation procedure tested in staging
- [ ] Documentation accessible to team

---

## References

- **Official Documentation**: https://github.com/bitnami-labs/sealed-secrets
- **Kubernetes Secrets**: https://kubernetes.io/docs/concepts/configuration/secret/
- **RBAC**: https://kubernetes.io/docs/reference/access-authn-authz/rbac/
- **Best Practices**: https://www.civo.com/learn/sealed-secrets-in-git

